\section{Analisis Komputasi Big Integer pada OpenSSL}
% \blindtext

\subsection{Implementasi Big Integer pada OpenSSL}
\todo[inline]{Jelasin openssl pake frns.}

Selain langsung melakukan operasi aritmatika terdapat juga bagian kode dalam OpenSSL yang melakukan beberapa fungsi lain. Sebagai contohnya, terdapat bagian kode yang melakukan pengecekan apakah OPENSSL\_SMALL\_FOOTPRINT terdefinisi dan melakukan fungsi yang diperlukan untuk mengkonversi tipe data yang digunakan agar cocok untuk versi OpenSSL yang terinstall. Pada subbab ini, bagian kode yang akan dianalisis hanyalah bagian kode yang relevan dengan algoritma operasi aritmatika tertentu. Bagian kode yang melakukan tugas lain seperti konfigurasi tipe data ataupun \textit{memory management} tidak akan dibahas.

% Kalo refer ke code, how to cite?
% \blindtext
\subsubsection{Penjumlahan dan Pengurangan}
OpenSSL menggunakan algoritma penjumlahan dan pengurangan standar dalam representasi FRNS seperti yang dibahas pada subbab \ref{sec:add_sub_theory}. OpenSSL melakukan operasi $mod$ dan $div$ dengan manipulasi bit, yaitu melakukan AND terhadap sebuah konstan untuk mendapat nilai $mod$ dan melakukan penggeseran bit untuk mendapatkan nilai $div$. Dengan demikian, OpenSSL dapat memotong overhead yang terjadi dibandingkan dengan melakukan operasi $div$ ataupun $mod$ yang terdapat dalam bahasa C.
% TODO: Cek lagi atas ^^

\subsubsection{Perkalian}
OpenSSL menggunakan algoritma karatsuba++

\subsubsection{Pembagian dan Modulo}
Jelasin pembagian

OpenSSL tidak memiliki fungsi khusus untuk operasi modulo. Karena fungsi untuk operasi pembagian sudah mengembalikan sisa dari pembagian, operasi modulo hanya perlu memanggil fungsi pembagian dengan argumen menggunakan argumen yang telah disesuaikan.

\subsection{Paralelisasi Algoritma}
% \blindtext
Terdapat dua strategi yang dapat digunakan untuk melakukan paralelisasi algoritma penjumlahan, pengurangan, dan perkalian. Strategi pertama adalah melakukan paralelisasi untuk algoritma dalam representasi FRNS. Sementara itu, strategi yang lain adalah melakukan konversi struktur FRNS yang digunakan oleh OpenSSL menjadi struktur RNS kemudian menjalankan operasi yang dibutuhkan dalam bentuk RNS.

Seperti yang dibahas pada subbab \ref{sec:rns}, RNS lebih mudah diparalelkan karena strukturnya terdiri dari komponen yang independen. Namun, konversi dari FRNS ke RNS memakan waktu yang cukup signifikan \todo{cite here, kasih data kalo nemu}. Selain itu, OpenSSL telah membuat stuktur BN\_CTX yang dapat menyimpan sejumlah struktur BIGNUM dalam memori. Penggunaan BN\_CTX membuat program dijalankan lebih cepat karena program tidak menunggu selesainya alokasi memori dalam pembuatan struktur BIGNUM. Program dapat menggunakan struktur yang tersimpan tersebut dibandingkan dengan membuat sebuah struktur baru yang hanya digunakan sesaat.

Subbab \ref{sec:add_sub_parallel} hingga \ref{sec:div_parallel} akan membahas cara paralelisasi algoritma operasi aritmatika dalam representasi FRNS.

\subsubsection{Penjumlahan dan Pengurangan}\label{sec:add_sub_parallel}
bagi chunks, assign ke berbeda, gabungin, parallel array processing biasa

\missingfigure{Ilustrasi pembagian penjumlahan}

\subsubsection{Perkalian}
Penggunaan Algoritma Karatsuba oleh OpenSSL mempermudah, cuma perlu

\subsubsection{Pembagian}\label{sec:div_parallel}
% etc, ntar ditambahin
