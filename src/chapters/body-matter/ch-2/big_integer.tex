\section{Big Integer}
% Arithmetic di komputer
Komputasi matematis di dalam sebuah komputer dilakukan oleh Arithmetic Logic Unit (ALU) yang terdapat di dalam CPU. Karena ALU adalah komponen yang sangat sederhana, ALU memiliki banyak batasan, salah satunya adalah ALU hanya dapat beroperasi pada bilangan bulat dalam \textit{range} tertentu \citep{comp_org_arch}. Pada umumnya, sebuah CPU memiliki 32-bit atau 64-bit ALU, nilai maksimum bilangan bulat yang dapat diproses oleh ALU tersebut hanya sebesar $2^{64}$. Kemampuan ALU untuk menangani bilangan pada \textit{range} tertentu berdasarkan jumlah bit yang dimilikinya biasa dikenal sebagai \textit{fixed-precision integer arithmetic}.

% Big number, Apa itu, kenapa dibutuhkan, dikenal juga sebagai Arbitrary/multi precision
Untuk menangani operasi matematis yang menggunakan bilangan yang lebih besar dari \textit{range} yang dimiliki ALU, diperlukan sebuah struktur data yang dapat menangani bilangan bulat tersebut. Kemampuan komputer untuk menghitung bilangan yang tidak memiliki batas sering dikenal sebagai \textit{arbitrary-precision integer arithmetic}. Sementara itu, bilangan yang digunakan dalam perhitungan tersebut sering disebut \textit{big number} atau \textit{big integer} jika bilangan yang digunakan adalah bilangan bulat.

% dipake dimana aja
\textit{Big integer} sering digunakan pada perhitungan kriptografi, mengingat bahwa perhitungan kriptografi membutuhkan bilangan yang besar agar kunci yang digunakan aman. Untuk implementasi kriptografi yang aman, disarankan untuk menggunakan kunci sebesar 256bit untuk AES dan kunci sebesar 1024 bit untuk RSA \citep{key_suggestion}, lebih besar dari jumlah bit yang dimiliki oleh ALU. Selain perhitungan kriptografi, big number juga umum digunakan untuk menghitung nilai konstanta matematis seperti $\pi$ \citep{bn_pi}, .
% \blindtext
\subsection{Struktur Big Integer}

Big integer memiliki dua representasi yang umum digunakan, yaitu Fixed Radix Number Systems (FRNS) dan Residue Number Systems (RNS). FRNS merupakan representasi bilangan dimana bilangan dituliskan sebagai penjumlahan dari komponen-komponennya \citep{modern_comp_math}. Sebuah RNS memiliki himpunan $H$ yang memiliki elemen bilangan bulat $\{m_1,m_2,...,m_p\}$, representasi integer $X$ adalah sebuah himpunan $H_x$ dimana elemennya adalah $X \mod m_i$ \citep{rns_survey}. Subbab \ref{sec:frns} menjelaskan lebih lanjut mengenai FRNS, sementara RNS dijelaskan lebih jauh pada subbab \ref{sec:rns}.

Penggunaan RNS maupun FRNS masing-masing memiliki kekurangan dan kelebihan yang berbeda. Pendekatan berbasis komponen pada RNS menyebabkan operasi aritmatika pada RNS dapat dijalankan secara paralel, dengan tidak adanya ketergantungan untuk masing-masing elemen himpunan. Namun, beberapa operasi aritmatika dasar seperti pembagian dan perbandingan antar dua bilangan akan menjadi lebih lambat \citep{gpu_bignum}.

\subsubsection{Fixed Radix Number Systems} \label{sec:frns}

\citet{modern_comp_math} menyatakan bahwa sebuah bilangan bulat dapat direpresentasikan sebagai penjumlahan dari komponen-komponennya. Jika kita memilih sebuah bilangan bulat positif $\beta$ sebagai basis dengan $\beta > 1 $ semua bilangan bulat positif $A$ berbasis $\beta$ yang memiliki panjang $n$ dapat dituliskan sebagai:
\begin{equation} \label{eq:frns_rep}
  A = \alpha_{n-1}\beta^{n-1}+...+\alpha_{1}\beta+\alpha_{0}
\end{equation}
dengan $0 \leq \alpha \leq \beta -1$.

Representasi integer positif di komputer 64 bit menggunakan $\beta = 2$ dan $n = 32$ sehingga nilai maksimum yang dapat direpresentasikan adalah $2^{64}$. Untuk representasi big integer nilai $n$ tidak memiliki batas, sementara nilai $\beta$ yang digunakan sesuai dengan jumlah maksimum bilangan dapat diproses pada komputer tersebut. Pada representasi big integer di komputer 64 bit, digunakan $\beta = 2^{64}$.

% Physical yang umum, array
% masuk bab 3?
Representasi ideal big integer pada komputer adalah menggunakan list of integer atau array of integer. Penggunaan list menyebabkan big integer tidak memiliki nilai maksimum, sementara itu penggunaan array membuat akses nilai yang tersimpan lebih cepat. Dengan demikian, penggunaan array of integer lebih umum digunakan untuk merepresentasikan big integer. Ilustrasi array of integer yang merepresentasikan big integer dapat dilihat pada Gambar \ref{fig:frns_ref}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/ch-2/frns-ref.png}
  \caption{Representasi FRNS dalam bentuk Array of Integer}
  \label{fig:frns_ref}
\end{figure}

% \blindtext
\subsubsection{Residue Number Systems} \label{sec:rns}
\citet{rns_survey} menyatakan bahwa RNS memiliki sebuah himpunan bilangan bulat relatif prima $\{m_1,m_2,...,m_p\}$. Nilai terbesar yang dapat direpresentasikan oleh RNS adalah sebesar $M$, dimana

\begin{equation}
  M = m_1 * m_2 * ... * m_p
\end{equation}

Sebuah bilangan bulat $X$ memiliki sebuah representasi RNS ${x_1,x_2,...,x_p}$ dengan $X_i$ adalah

\begin{equation}
  X_i = X \mod m_i
\end{equation}

\todo[inline]{Tambahin penjelasan lebih jauh tentang Chinese Remainder Theorem disini}
\todo[inline]{Jelasin karena bentuknya set, tiap elemen ga mempengaruhi satu sama lain, lebih mudah diparalelkan}

\subsection{Operasi Aritmatika}
% \blindtext
Proses operasi aritmatika yang dilakukan dalam representasi FRNS dan RNS berbeda. Karena itu, subbab \ref{sec:add_sub_theory} sampai subbab \ref{sec:mod_mul_theory} akan membahas bagaimana setiap operasi aritmatika dilakukan pada masing-masing operasi.

\subsubsection{Penjumlahan dan Penguragan} \label{sec:add_sub_theory}
\paragraph{Representasi FRNS}

Operasi penjumlahan dan pengurangan pada FRNS dilakukan dengan cara penjumlahan dan pengurangan manual oleh tangan. Merujuk pada persamaan \ref{eq:frns_rep}, proses penjumlahan dan pengurangan dilakukan dari $\alpha_0$ hingga $\alpha_{n-1}$ dengan menggunakan bilangan \textit{carry over} dan \textit{borrow} jika dibutuhkan.

Untuk penjumlahan dan pengurangan dua bilangan $A = a_{n-1}\beta^{n-1}+...+a_{1}\beta+a_{0}$ dan $B = b_{n-1}\beta^{n-1}+...+b_{1}\beta+b_{0}$, akan dihasilkan bilangan $C = c_{n-1}\beta^{n-1}+...+c_{1}\beta+c_{0}$. Algoritma yang dapat digunakan untuk menghitung C

\begin{algorithm}
  \caption{Paralelisasi fungsi penjumlahan}
    \label{alg:packed-dna-hamming}
  \begin{algorithmic}[1]
    \Require{$x$ dan $y$ adalah array [1..n] yang merepresentasikan Big Integer, $num$ adalah jumlah task}
    \Statex
    \Function{AddParallel}{$x$, $y$, $num$}
      \Let{$x_{chunks}$}{Split($x$)}
      \Let{$y_{chunks}$}{Split($y$)}
      \Let{$result\_arr$}{NewArray}
      \ForAll{$i$, $j$ in $x_{chunks}$, $y_{chunks}$}
          \Let{$job$}{StartJob(add($i$,$j$))}
          \Let{$sum$, $carry$}{GetJobResult($job$)}
          \State append((sum, carry), $result\_arr$)
      \EndFor
      \State \Return{ResolveCarry($result\_arr$)}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{lstlisting}[style=algorithm]
function add(A[0..n], B[0..n]) {
    C := [0..n]
    carry := 0
    iterate 0 to n as i {
        n := carry + A[i] + B[i]
        carry := n div $\beta$
        C[i] := n mod $\beta$
    }
    return C, carry
}
\end{lstlisting}


% Cek lagi pengurangan. Ga yakin..

\paragraph{Representasi RNS}

\citet{rns_sharoun} menyatakan bahwa dalam sistem RNS dengan elemen $\{m_1,m_2,...,m_p\}$, penjumlahan dan pengurangan dua bilangan $A$ dan $B$ yang memiliki representasi RNS $\{b_1,b_2,...,b_p\}$ dan $\{b_1,b_2,...,b_p\}$,  menghasilkan $C$ yang memiliki representasi $\{c_1,c_2,...,c_p\}$ dengan nilai $c_i$ sebagai berikut
\begin{equation}
    c_i = (a_i \pm b_i) \mod m_i
\end{equation}


\subsubsection{Perkalian}

\paragraph{Representasi FRNS}
Terdapat beberapa algoritma yang dapat dilakukan dalam perkalian dua bilangan besar. Pada subbab ini hanya akan dibahas dua algoritma perkalian, yaitu algoritma perkalian panjang dan algoritma perkalian Karatsuba. Dua algoritma tersebut dibahas karena algoritma perkalian dasar dibutuhkan untuk memahami dasar dari proses perkalian, sementara itu algoritma Karatsuba digunakan dalam implementasi perkalian pada OpenSSL.

Algoritma perkalian panjang adalah algoritma perkalian yang biasa diajarkan dalam sekolah dasar. Algoritma perkalian panjang $A*B$ berdasarkan pada proses mengkalikan satu digit A pada B, geser hasilnya sesuai posisi digit A yang digunakan, lalu jumlahkan seluruh hasil perkalian tersebut. Algoritma ini memiliki kompeksitas $O(n^2)$ terhadap perkalian. Berikut adalah algoritma perkalian panjang pada pseudocode.

\begin{lstlisting}[style=algorithm]
function mul(A[0..p], B[0..q], $\beta$) {
    C := [0..p+q]
    iterate 0 to p as i {
        carry := 0
        iterate 0 to q as j {
            n += carry + a[i] * b[j]
            carry = n div $\beta$
            C[i+j-1] = n mod $\beta$
        }
        C := carry
    }
    return C
}
\end{lstlisting}

Algoritma karatsuba berdasarkan bahwa perkalian dua bilangan A dan B dapat direpresentasikan dalam tiga perkalian bilangan bulat yang lebih kecil. Algoritma ini memiliki kompeksitas $O(n^{\log_2 3})$ terhadap operasi perkalian. Penggunaan algoritma karatsuba dalam komputer dapat dilakukan dengan pemanggilan fungsi secara rekursif. Berikut adalah algoritma perkalian Karatsuba dalam pseudocode.
\todo{perlu dijelasin teori lebih lanjut ga?}

\begin{lstlisting}[style=algorithm]
function mul_karatsuba(A[1..p], B[1..q], $\beta$) {
    if (p = 1) or (q = 1)
        return B*A

    mid := floor(min(p,q)/2)

    low_a := A[1..mid]
    high_a := A[mid..p]
    low_b := B[1..mid]
    high_b := B[mid..q]

    x = karatsuba(low_a, low_b)
    y = karatsuba((low_a + high_a), (low_b + high_b))
    z = karatsuba(high_a, high_b)

    return (z * $\beta$ ^ (mid * 2)) + ((y - z - x) * $\beta$ ^ mid) + x
}
\end{lstlisting}


\paragraph{Representasi RNS}
Sifat penjumlahan dan pengurangan yang dibahas pada subbab \ref{sec:add_sub_theory} juga berlaku pada perkalian di representasi RNS. Perkalian dua bilangan $A$ dan $B$ dalam representasi RNS, akan menghasilkan $C$ yang memiliki representasi $\{c_1,c_2,...,c_p\}$ dengan nilai $c_i$ sebagai berikut
\begin{equation}
    c_i = (a_i * b_i) \mod m_i
\end{equation}

\subsubsection{Pembagian dan Modulo}

\paragraph{Representasi FRNS}
Seperti perkalian, terdapat beberapa algoritma yang dapat digunakan dalam pembagian. Algoritma yang paling mudah dilakukan adalah dengan melakukan pengurangan berkali-kali seperti yang dijelaskan oleh Euclid. \todo{tambahin citation}. Berikut adalah algoritma pembagian dengan pengurangan berkali-kali dalam pseudocode.

\begin{lstlisting}[style=algorithm]
function div_repeated_sub(N, D) {
    Q := 0
    R := N
    while R >= D {
        Q := Q + 1
        R := R - D
    }

    return (Q, R)
}
\end{lstlisting}

\citet{div_burnikel_ziegler} memperkenalkan algoritma pembagian cepat yang berjalan pada kompleksitas $2K(n)+O(n \log n)$ dengan $K(n)$ adalah waktu berjalannya algoritma perkalian karatsuba.
\todo[inline]{jelasin dasarnya apa, div\&conquer, recursive}

\begin{lstlisting}[style=algorithm]
function div_burnikel_ziegler(N, D) {

}
\end{lstlisting}

\paragraph{Representasi RNS}

Pembagian dalam RNS cukup kompleks. Mengingat bahwa kinerja pembagian pada RNS pasti lebih buruk dibandingkan dengan pembagian pada FRNS, maka algoritma pembagian pada RNS tidak dibahas lebih lanjut.
